# Philosophers

원탁에 둘러 앉은 철학자들이 최대한 굶어 죽지 않도록 구현하는 과제이다. 

철학자는 식사, 수면, 생각 중 한가지를 하고 있다.  
주어진 시간 안에 식사를 하지 않으면 사망한다.  
식사를 마치면 수면에 들어가고, 수면을 마치면 생각을 한다.  
식사는 양 옆에 있는 2개의 포크로 한다. 두 철학자 사이에 1개의 포크가 존재한다.  

프로그램은 다음의 인자를 순서대로 받는다.
- 철학자의 수
- 철학자의 수명
- 식사하는 데 걸리는 시간
- 수면하는 데 걸리는 시간
- 철학자의 최소 식사 횟수

모든 철학자가 최소 식사 횟수만큼 밥을 먹었다면 시뮬레이션이 종료됩니다. 만약에 해당 값이 없다면 철학자가 한 명이라도 사망할 때까지 계속된다.

컨텍스트 스위칭에 소요되는 시간으로 인해서 시간이 늘어간다.

스레드를 non-detached로 생성한 경우에는 pthread_join으로 자원을 메모리에서 해제해주어야 한다. 메인 스레드에서 pthread_join을 호출하면 인자로 넘긴 스레드가 종료될 때까지 기다린다.
스레드를 detached로 생성한 경우에는 join을 호출할 필요없이 스레드가 종료될때 자원이 자동으로 반환된다.
[join과 detach의 차이점](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=shlee7708&logNo=120113380564)



## todos

- [x]  argv 처리
- [x]  철학자 객체 생성
- [x]  mutex로 식사 구현
- [x]  옵저버 쓰레드 구현
    - [x]  철학자 구조체 배열을 넘겨받는다.
    - [x]  시간을 구하여 철학자가 죽어야 하는지 확인한다.
    - [x]  한 철학자가 죽게되면 모든 철학자 구조체에 알린다.
- [x]  출력 순서가 섞이지 않도록 동기화시킨다.
- [x]  mutex로 printf 구현
- [x]  시간 적용
    - [x]  철학자 수명 (밥을 먹고 일정 시간이 지나면 죽는다.)
    - [x]  밥먹는 시간 (밥먹는 시간)
    - [x]  잠자는 시간 (식사 후 잠을 자는데 소모되는 시간)
    - [x]  철학자의 상태를 출력 ( time | id | state )
- [x]  옵저버의 종료 조건
  - [x]  철학자의 수명이 다한 경우
  - [x]  모든 철학자가 최소 식사 횟수만큼 식사를 완료한 경우
    - [x]  옵저버에서 count한다.
    - [x]  철학자가 자신이 최소 식사를 마쳤음을 옵저버에게 알렸는지 확인하는 플래그를 가짐
    - [x]  모든 철학자가 식사를 완료하면 종료
- [x]  스레드를 모두 detached로 변경
- [x]  프로그램 종료 mutex를 생성
  - [x]  옵저버에 term_mutex를 넘긴다.
- [x]  옵저버의 프로그램 종료
  - [x]  종료 조건에 충족한 경우에 프로그램을 종료
  - [x]  term_mutex의 잠금을 해제
  - [x]  main에서 term_mutex를 받아서 프로그램을 종료
- [x]  리팩토링
  - [x]  코드 분할
  - [x]  파일 정리
  - [x]  구조 정리
- [ ]  철학자가 최대한 죽지 않는 방법 (시간 지연 문제)
  - [x]  usleep 함수의 오차 해결
    - 반복문으로 목표 시간까지 시간을 계산해서 usleep 실행
    - (목표 시간 - 현재 시간) / 2
    - 만약에 (목표 시간 - 현재 시간)이 100us 보다 적다면 그대로 실행
  - [ ]  ~~상태 메시지를 철학자 스레드가 아닌 다른 스레드에서 출력~~
    - 스레드를 생성하는만큼 오버헤드가 걸려서 오히려 시간이 더 지연될 수 있다.
  - [ ]  오버헤드 최소화 또는 오버헤드를 고려한 구조
    - [ ]  시작할 때 포크를 하나씩 가져간다.
